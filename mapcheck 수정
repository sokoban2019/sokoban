#include<stdio.h>
#include<termio.h>
#include<stdlib.h>


void loadMap();
void prtMap();
void command();
void map_Check();
void checkclear();
void Save();
void up();
void down();
void right();
void left();
void New();
void undo();
void file();
void display();
void undoupdate();
void undoupdate_first();
void re();

//
void saverank();
void top();

int stage = 0, move, STAGE = 0;
char map[5][30][30];
char undomap[5][30][30];
char Original_map[5][30][30];
int player_x[5], player_y[5];
int max_x[5], max_y[5];
int undocount = 5;
char USER[11];
char Copy_map[5][30][30];
int Copy_player_x[5];
int Copy_player_y[5];



int getch(void) {
	int ch;
	struct termios buf, save;
	tcgetattr(0, &save);
	buf = save;
	buf.c_lflag &= ~(ICANON | ECHO);
	buf.c_cc[VMIN] = 1;
	buf.c_cc[VTIME] = 0;
	tcsetattr(0, TCSAFLUSH, &buf);
	ch = getchar();
	tcsetattr(0, TCSAFLUSH, &save);
	return ch;
}


int main()
{
	loadMap();
	map_Check();

	printf("Start..\nInput name :");
	scanf("%s", USER);

	undoupdate_first();
	command();

}

void command()
{
	char usr;
	int i, j, k;
	


	while (1)
	{
		prtMap();

		usr = getch();

		switch (usr)
		{
		case 'h':
			undoupdate();
			left();
			break;

		case 'j':
			undoupdate();
			down();
			break;

		case 'k':
			undoupdate();
			up();
			break;

		case 'l':
			undoupdate();
			right();
			break;

		case 'e':
			Save();
			printf("SEE YOU...%s", USER);
			exit(1);
			break;

		case 's':
			Save();
			break;

		case 'n':
			New();
			undoupdate_first();
			break;

		case 'u':
			undo();
			break;

		case 'r':
			re();
			break;

		case 'f':
			file();
			break;

		case 'd':
			display();
			break;

		case 't':
			top();
			break;

		}








		checkclear();
		if (stage == 5)
		{
			printf("\nGAME CLEAR!");
			char a = ' ';

			while (a != '\n')
			{

				a = getch();
			}

			exit(1);

		}


	}
}



void display()
{
	system("clear");

	printf("Hello %s\n", USER);
	printf("h(왼쪽), j(아래), k(위), l(오른쪽)\n");
	printf("u(undo)\n");
	printf("r(replay)\n");
	printf("n(new)\n");
	printf("e(exit)\n");
	printf("s(save)\n");
	printf("f(file load)\n");
	printf("d(display help)\n");
	printf("t(top)\n");

	char a = ' ';
	while (a != '\n')
	{
		a = getch();

	}

	return;

}

void loadMap() {
	FILE *fp = fopen("map.txt", "r");
	int x = 0, y = 0, STAGE = 0;
	char temp;

	for (int c = 0; c < 5; c++)
	{
		max_x[c] = 0;
		max_y[c] = 0;
	}

	while (1) {
		fscanf(fp, "%c", &temp);
		if (temp == 'e') break;

		if (temp >= '1' && temp <= '5') {
			if (temp != '1') {
				x = y = 0;
				STAGE++;
			}

			fscanf(fp, "\n", &temp);
		}
		else {
			if (temp == '@') {
				player_x[STAGE] = x;
				player_y[STAGE] = y;
			}

			map[STAGE][x][y] = temp;
			Original_map[STAGE][x][y] = (temp == '@' || temp == '$') ? '.' : temp;
			x++;
			if (y == 0) max_x[STAGE]++;

			if (temp == '\n') {
				x = 0;
				y++;
				max_y[STAGE]++;
			}
		}
	}

	fclose(fp);
	return;
}

void prtMap()
{
	system("clear");
	printf("Hello %s\n", USER);

	for (int y = 0; y < max_y[stage]; y++) {
		for (int x = 0; x < max_x[stage]; x++) {
			if (map[stage][x][y] == '.')
				printf(" ");
			else
				printf("%c", map[stage][x][y]);
		}
	}
}

void map_Check()
{

	int box_cnt[5]={0}, depository[5]={0};

	for (int i = 0; i<5; i++)
	{

		for (int j = 0; j<30; j++)
		{

			for (int k = 0; k<30; k++)
			{

				if (map[i][j][k] == '$')
					box_cnt[i]++;
				if (map[i][j][k] == 'O')
					depository[i]++;

			}
		}

	}
	for (int k = 0; k<5; k++)
	{
		if(box_cnt[k]!=depository[k]){
			printf("error\n");
			exit(1);
		}

	}



}

void checkclear()
{
	int flag = 1;
	for (int i = 0; i<max_y[stage]; i++) {
		for (int j = 0; j<max_x[stage]; j++) {
			if (Original_map[stage][j][i] == 'O') {
				if (map[stage][j][i] != '$')
					flag = 0;
			}
		}
	}
	if (flag) {
		saverank();
		move = 0;//
		undocount = 5;//
		stage++;
	}

}

void re() {
	system("clear");
	loadMap();

}

void New()
{
	system("clear");
	stage = 0;
	move = 0;
	undocount = 5;
	loadMap();


}


void left()
{
	int dx = 1;

	if (map[stage][player_x[stage] - dx][player_y[stage]] == '#') {
		move++;
	}
	else {

		if (map[stage][player_x[stage] - dx][player_y[stage]] == '$') {
			if (map[stage][player_x[stage] - dx - dx][player_y[stage]] == '#' || map[stage][player_x[stage] - dx - dx][player_y[stage]] == '$') {
				move++;
			}
			else {

				if (map[stage][player_x[stage] - dx - dx][player_y[stage]] == 'O') {
					move++;
					map[stage][player_x[stage]][player_y[stage]] = Original_map[stage][player_x[stage]][player_y[stage]];
					map[stage][player_x[stage] - dx][player_y[stage]] = '@';
					map[stage][player_x[stage] - dx - dx][player_y[stage]] = '$';
					player_x[stage]--;
				}
				else {
					move++;
					map[stage][player_x[stage]][player_y[stage]] = Original_map[stage][player_x[stage]][player_y[stage]];
					map[stage][player_x[stage] - dx][player_y[stage]] = '@';
					map[stage][player_x[stage] - dx - dx][player_y[stage]] = '$';
					player_x[stage]--;
				}
			}
		}
		else {
			move++;
			map[stage][player_x[stage]][player_y[stage]] = Original_map[stage][player_x[stage]][player_y[stage]];
			map[stage][player_x[stage] - dx][player_y[stage]] = '@';
			player_x[stage]--;
		}
	}
}

void up()
{
	int dy = 1;

	if (map[stage][player_x[stage]][player_y[stage] - dy] == '#') {
		move++;
	}
	else {

		if (map[stage][player_x[stage]][player_y[stage] - dy] == '$') {
			if (map[stage][player_x[stage]][player_y[stage] - dy - dy] == '#' || map[stage][player_x[stage]][player_y[stage] - dy - dy] == '$') {
				move++;
			}
			else {

				if (map[stage][player_x[stage]][player_y[stage] - dy - dy] == 'O') {
					move++;
					map[stage][player_x[stage]][player_y[stage]] = Original_map[stage][player_x[stage]][player_y[stage]];
					map[stage][player_x[stage]][player_y[stage] - dy] = '@';
					map[stage][player_x[stage]][player_y[stage] - dy - dy] = '$';
					player_y[stage]--;
				}
				else {
					move++;
					map[stage][player_x[stage]][player_y[stage]] = Original_map[stage][player_x[stage]][player_y[stage]];
					map[stage][player_x[stage]][player_y[stage] - dy] = '@';
					map[stage][player_x[stage]][player_y[stage] - dy - dy] = '$';
					player_y[stage]--;
				}
			}
		}
		else {
			move++;
			map[stage][player_x[stage]][player_y[stage]] = Original_map[stage][player_x[stage]][player_y[stage]];
			map[stage][player_x[stage]][player_y[stage] - dy] = '@';
			player_y[stage]--;
		}
	}
}

void down()
{
	int dy = 1;

	if (map[stage][player_x[stage]][player_y[stage] + dy] == '#') {
		move++;
	}
	else {

		if (map[stage][player_x[stage]][player_y[stage] + dy] == '$') {
			if (map[stage][player_x[stage]][player_y[stage] + dy + dy] == '#' || map[stage][player_x[stage]][player_y[stage] + dy + dy] == '$') {
				move++;
			}
			else {

				if (map[stage][player_x[stage]][player_y[stage] + dy + dy] == 'O') {
					move++;
					map[stage][player_x[stage]][player_y[stage]] = Original_map[stage][player_x[stage]][player_y[stage]];
					map[stage][player_x[stage]][player_y[stage] + dy] = '@';
					map[stage][player_x[stage]][player_y[stage] + dy + dy] = '$';
					player_y[stage]++;
				}
				else {
					move++;
					map[stage][player_x[stage]][player_y[stage]] = Original_map[stage][player_x[stage]][player_y[stage]];
					map[stage][player_x[stage]][player_y[stage] + dy] = '@';
					map[stage][player_x[stage]][player_y[stage] + dy + dy] = '$';
					player_y[stage]++;
				}
			}
		}
		else {
			move++;
			map[stage][player_x[stage]][player_y[stage]] = Original_map[stage][player_x[stage]][player_y[stage]];
			map[stage][player_x[stage]][player_y[stage] + dy] = '@';
			player_y[stage]++;
		}
	}
}

void right()
{
	int dx = 1;

	if (map[stage][player_x[stage] + dx][player_y[stage]] == '#') {
		move++;
	}
	else {

		if (map[stage][player_x[stage] + dx][player_y[stage]] == '$') {
			if (map[stage][player_x[stage] + dx + dx][player_y[stage]] == '#' || map[stage][player_x[stage] + dx + dx][player_y[stage]] == '$') {
				move++;
			}
			else {

				if (map[stage][player_x[stage] + dx + dx][player_y[stage]] == 'O') {
					move++;
					map[stage][player_x[stage]][player_y[stage]] = Original_map[stage][player_x[stage]][player_y[stage]];
					map[stage][player_x[stage] + dx][player_y[stage]] = '@';
					map[stage][player_x[stage] + dx + dx][player_y[stage]] = '$';
					player_x[stage]++;
				}
				else {
					move++;
					map[stage][player_x[stage]][player_y[stage]] = Original_map[stage][player_x[stage]][player_y[stage]];
					map[stage][player_x[stage] + dx][player_y[stage]] = '@';
					map[stage][player_x[stage] + dx + dx][player_y[stage]] = '$';
					player_x[stage]++;
				}
			}
		}
		else {
			move++;
			map[stage][player_x[stage]][player_y[stage]] = Original_map[stage][player_x[stage]][player_y[stage]];
			map[stage][player_x[stage] + dx][player_y[stage]] = '@';
			player_x[stage]++;
		}
	}
}

void undoupdate_first()
{


	for (int c = 0; c<5; c++)
	{
		for (int i = 0; i<max_x[stage]; i++)
		{
			for (int j = 0; j<max_y[stage]; j++)
			{
				undomap[c][i][j] = map[stage][i][j];
			}
		}
	}

}

void undoupdate()
{

	for (int c = 5; c>1; c--)
	{
		for (int i = 0; i<max_x[stage]; i++)
		{
			for (int j = 0; j<max_y[stage]; j++)
			{

				undomap[c - 1][i][j] = undomap[c - 2][i][j];
			}
		}
	}

	for (int k = 0; k<max_x[stage]; k++)
	{
		for (int l = 0; l<max_y[stage]; l++)
		{
			undomap[0][k][l] = map[stage][k][l];
		}
	}

	for (int p = 4; p >= 1; p--)
	{
		Copy_player_x[p] = Copy_player_x[p - 1];
		Copy_player_y[p] = Copy_player_y[p - 1];

	}

	Copy_player_x[0] = player_x[stage];
	Copy_player_y[0] = player_y[stage];

}

void undo()
{
	if (undocount == 0)
	{
		printf("undo finished");
		return;
	}
	player_x[stage] = Copy_player_x[0];
	player_y[stage] = Copy_player_y[0];

	for (int p = 0; p < 4; p++)
	{
		Copy_player_x[p] = Copy_player_x[p + 1];
		Copy_player_y[p] = Copy_player_y[p + 1];

	}

	for (int i = 0; i<max_x[stage]; i++)
	{
		for (int j = 0; j<max_y[stage]; j++)
		{
			map[stage][i][j] = undomap[0][i][j];
		}
	}

	for (int c = 0; c<4; c++)
	{
		for (int i = 0; i<max_x[stage]; i++)
		{
			for (int j = 0; j<max_y[stage]; j++)
			{
				undomap[c][i][j] = undomap[c + 1][i][j];
			}
		}
	}


	undocount--;
}

void Save()
{
	FILE *save;

	save = fopen("sokoban.txt", "w");

	fprintf(save, "%s\n", USER);
	fprintf(save, "%d\n", undocount);
	fprintf(save, "%d\n", move);
	fprintf(save, "%d\n", stage);

	for (int i = 0; i < max_y[stage]; i++)
	{
		for (int j = 0; j < max_x[stage]; j++)
		{
			fprintf(save, "%c", map[stage][j][i]);
		}
	}

	fclose(save);
}

void file()
{
	FILE *fileload;
	char ch;
	int x = 0, y = 0;

	fileload = fopen("sokoban.txt", "r");

	if (fileload == NULL) exit(1);


	fscanf(fileload, "%s\n%d\n%d\n%d\n", &USER, &undocount, &move, &stage);

	while (fscanf(fileload, "%c", &ch) != EOF) {
		map[stage][x][y] = ch;
		printf("%c", ch);

		if (ch == '@') {
			player_x[stage] = x;
			player_y[stage] = y;
		}

		if (ch == '\n') {
			y++;
			x = 0;
		}
		else {
			x++;
		}
	}

	fclose(fileload);
	prtMap();
}

void saverank()
{
	FILE *rank;



			rank = fopen("ranking.txt", "a");

			fprintf(rank, "%d %s %d\n", stage, USER, move);
		

	fclose(rank);

}

void top()
{
	FILE *top;
	int temp;
	
	int i = 0;
	int s[100];
	char n[100][11];
	int m[100];

	top = fopen("ranking.txt", "r");
	system("clear");
	printf("Hello %s\n", USER);
	
	do
	{
		
		temp=fscanf(top, "%d %s %d\n", &s[i],&n[i],&m[i]);
	
		if (temp == EOF)
			break;
		

		printf("%d %s %d\n", s[i]+1, n[i], m[i]);

		i++;


	} while (temp != EOF);

	fclose(top);

	char a = ' ';
	while (a != '\n')
	{
		a = getch();

	}

}
